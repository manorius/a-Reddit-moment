#!/usr/bin/env node
"use strict";

// Auto generates the endpoints from the Reddit API.
// Recommend running tests after running this to make sure things are
// still the same & we haven't missed any updates

var path = require('path');
var when = require('when');
var mu = require('mu2');
var request = require('request');
var cheerio = require('cheerio');

function getEndpointOauth($, endpoint) {
  var $oauthList = $(endpoint).find('.oauth-scope-list');

  var oauth = $oauthList.length === 0
				? []
				: $oauthList.toArray().map(function(e) { return $(e).text(); });

  return oauth;
}


function getEndpointExtensions($, endpoint) {
  var $exts = $('.extensions', $(endpoint));

  var extensions = $exts.length === 0
				? []
				: $exts.text().replace(/[^\w\. ]/g, '').trim().split(/ +/);

  return extensions;
}

function getEndpointUrl(method, path, hasOauth, options) {
  options = options || {};
  var url = {};

  if (hasOauth) {
    url.oauth = 'https://oauth.reddit.com' + path;
    if (options.skipFullUrls) {
      url.oauth = '';
    }
  }

  url.standard = (method === 'GET'
			 ? 'https://www.reddit.com'
			 : 'https://ssl.reddit.com') + path;

  if (options.skipFullUrls) {
    url.standard = '';
  }

  return url;
}

function getEndpointDescription($, endpoint) {
  return $('.md', $(endpoint)).text().replace(/\n$/, '');
}

function getEndpointArgs($, endpoint) {
  var args = {};

  if ($(endpoint).find('.parameters')) {
    args = $(endpoint).find('tr').toArray().map(function(element) {
      return {
	// to deal with "uh / X-Mod ..."
	paramName: $($(element).find('th')).text().split(' ')[0],
	paramDesc: $($(element).find('td')).text().replace(/\n$/, '')
      };
    }).reduce(function(prev, curr) {
      prev[curr.paramName] = {
	describe: curr.paramDesc
      };
      return prev;
    }, {});
  }

  return args;
}

function getEndpointMethod($, endpoint) {
  return $('.method', $(endpoint)).text().trim();
}

// checks if an endpoint is a listing. This is true when the
// following keys exist in the arguments: before, after, limit
// count & show
function isEndpointListing(endpointArgs) {
  var keys = Object.keys(endpointArgs);
  var needed = [ 'before', 'after', 'limit', 'count', 'show' ];

  for (var i = needed.length - 1; i >= 0; --i) {
    if (keys.indexOf(needed[i]) === -1) { return false }
  }

  return true;
}

function getEndpointPaths($, endpoint) {
  var endpointPaths = []; // all of the paths for this endpoint

  // clone so we're not modifying the actual endpoint
  var $endpoint = $(endpoint).clone();

  // remove the following from the h3 tags to get a proper path
  $('.extensions', $endpoint).remove();
  $('.method', $endpoint).remove();
  $('.oauth-scope-list', $endpoint).remove();

  // normalize a single path (may result in multiple paths if
  // the path contains "optional" sections with brackets)
  //
  // takes a cheerio object to work with that has an url in it
  function normalizePath($url) {
    var paths = []; // paths as a results of normalizing

    var placeholders = $('.placeholder', $h3).toArray().map(function(p) {
      return $(p).text();
    });

    var rawPath = $url.text().trim();

    // If we have brackets to handle, remove them
    if (rawPath.indexOf('[') !== -1 && rawPath.indexOf(']') !== -1) {
      var noBracketPath = rawPath.replace(/\[.*\]/g, '') // remove anything in brackets
				 .replace(/[^\w\/\.]/g, ''); // remove anything else

      placeholders.forEach(function(p) {
	noBracketPath = noBracketPath.replace(p, '$' + p);
      });

      paths.push(noBracketPath);
    }

    var fullPath = rawPath.replace(/[^\w\/\.]/g, '');

    placeholders.forEach(function(p) {
      fullPath = fullPath.replace(p, '$' + p);
    });

    paths.push(fullPath);
    return paths;
  }

  // The "main" route
  var $h3 = $('h3', $endpoint);
  endpointPaths = endpointPaths.concat(normalizePath($h3));

  // Add any subroutes that appear below the main one
  endpointPaths = $('.uri-variants > li', $endpoint).toArray().reduce(function(routes, subroute) {
    routes = routes.concat(normalizePath($(subroute)));
    return routes;
  }, endpointPaths);

  return endpointPaths;
}

function getDetails(details, options) {

  var ret = {};
  options = options || {};

  if (!details.path || !details.url) {
    throw new Error('missing url');
  }

  ret.path = details.path;

  if (!options.skipUrls) {
    ret.url = details.url;
  }

  ret.oauth = details.oauth ||  [];
  ret.extensions = details.extensions ||  [];
  ret.method = details.method ||  'GET';

  if (!options.skipDescription) {
    ret.describe = details.describe ||  '';
  }

  if (!options.skipArgs) {
    ret.args = details.args ||  {};

    // remove the description for the arguments
    if (options.skipArgsDescription) {
      Object.keys(ret.args).forEach(function(key) {
	delete ret.args[key].describe;
      });
    }
  }

  ret.isListing = details.isListing;

  return ret;
}

function getEndpointDetails($, endpoint, options) {
  options = options || {};

  var method = getEndpointMethod($, endpoint);
  var paths = getEndpointPaths($, endpoint);
  var oauth = getEndpointOauth($, endpoint);
  var endpointArgs = getEndpointArgs($, endpoint);

  return paths.map(function(path) {
    return getDetails({
      oauth: getEndpointOauth($, endpoint),
      extensions: getEndpointExtensions($, endpoint),
      method: method,
      path: path,
      url: getEndpointUrl(method, path, oauth.length > 0, options),
      describe: getEndpointDescription($, endpoint),
      args: endpointArgs,
      isListing: isEndpointListing(endpointArgs)
    }, options);
  });
}

function getEndpoints($, options) {
  options = options || {};
  var endpoints = [];
  $('.endpoint').toArray().forEach(function(endpoint) {
    endpoints = endpoints.concat(getEndpointDetails($, endpoint, options));
  });
  return endpoints;
}

function getRedditHtml() {
  var apiHtml = when.defer();
  var site = 'http://www.reddit.com/dev/api';

  request(site, function(error, response, body) {
    return error ? apiHtml.reject(error) : apiHtml.resolve(body);
  });

  return apiHtml.promise;
}

exports.api = function(options) {
  options = options || {}
  return getRedditHtml().then(function(html) {
    var $ = cheerio.load(html);
    return getEndpoints($, options);
  });
};

// @TODO test
exports.jsonApi = function(options) {
  options = options || {};
  return exports.api(options).then(function(data) {
    var json = options.minify ? 
	       JSON.stringify(data) :
	       JSON.stringify(data, null, 4);
    return json;
  });
};

// @TODO test
function getTemplateString(template, data) {
  var defer = when.defer();
  var stream = mu.compileAndRender(template, data);
  var out = '';

  stream.on('data', function(chnk) { out += chnk.toString(); });
  stream.on('end', function() { return defer.resolve(out); });
  stream.on('error', defer.reject);

  return defer.promise;
}

// @TODO test
exports.nodeApi = function(options) {
  options = options || {};
  return exports.api(options).then(function(data) {
    var template = path.join(__dirname, 'templates', 'api_node.mu.js');

    return getTemplateString(template, {
      data : JSON.stringify(data)
    });
  });
};

// @TODO test
exports.amdApi = function(options) {
  options = options || {};
  return exports.api(options).then(function(data) {
    var template = path.join(__dirname, 'templates', 'api_amd.mu.js');

    return getTemplateString(template, {
      data : JSON.stringify(data)
    });
  });
};

// expose private functions for testing
exports._test = {
  getEndpointOauth: getEndpointOauth,
  getEndpointExtensions: getEndpointExtensions,
  getEndpointUrl: getEndpointUrl,
  getEndpointDescription: getEndpointDescription,
  getEndpointArgs: getEndpointArgs,
  getEndpointMethod: getEndpointMethod,
  getEndpointPaths: getEndpointPaths,
  isEndpointListing: isEndpointListing,
  getEndpointDetails: getEndpointDetails,
  getEndpoints: getEndpoints,
  getRedditHtml: getRedditHtml
};

var man = __dirname + '/man/reddit-api-generator.1.md';
require('main').run(module, man, function($) {

  if ($('h') || $('help')) {
    console.log(require('fs').readFileSync(man, { encoding: 'utf8' }));
    process.exit();
  }

  var build;

  var options = {};
  options.minify = $('minify');
  options.skipDescription = $('skip-desc');
  options.skipArgs = $('skip-args');
  options.skipArgsDescription = $('skip-args-desc');

  options.skipUrls = $('skip-urls');
  options.skipFullUrls = $('skip-full-urls');

  switch ($('build-for')) {
    case 'json':
      build = exports.jsonApi(options);
      break;
    case 'node':
      build = exports.nodeApi(options);
      break;
    case 'amd':
      build = exports.amdApi(options);
      break;
    default:
      build = when.reject(new Error('Invalid "build-for" provided'));
  }

  build.done(console.log);
});
